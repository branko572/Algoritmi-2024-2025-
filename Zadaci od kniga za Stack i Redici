Задача 1. Поништување топчиња
Да се напише алгоритам со коj ´ке се имплементира играта “Поништување топчиња”. Во оваа игра на располагање имате топчиња во три различни бои (R-црвена,
G-зелена и B-сина), обележани со знакот + или -. Поништување на топчиња може да настане само доколку тие се од иста боjа и со спротивен знак. На почеток
се генерира една случаjна листа со топчиња. Ваша задача е од тоj влез, како
доа´гаат топчињата да направите поништување и да кажете колку, од каков тип
(+ или -) и од коjа боjа фалат за да се поништат сите топчиња од влезот.
Влез: Во влезот е дадена листа од случаjни топчиња и тоа во облик: боjа,
знак.
Излез: На излез треба да се испечатат броjот на парови и паровите кои може
да се формираат.
Пример:
Влез: R+ G- G+ G+ R+ B- B+ R- G+ R- B- B+ B+ R+
Парови кои може да се формираат од овоj список се: (R+,R-); (B+, B-); (BB+); (R+, R-); (G-, G+); (R+, R-) Остануваат без партнер: G+, G+, B+, R+
Излез:
4
R- G- G- B+
Решение
Во дадената задача треба да се имплементира игра со топчиња во три различни
бои (R-црвена, G-зелена и B-сина), обележани со знакот + или -, каде се прави
поништување на топчињата само доколку тие се од иста боjа и со спротивен знак.
За да се одговори на барањата од задачата мора да се искористат 3 податочни
структури стек (crveni, zeleni и sini) за да се чуваат топчињата со соодветните
бои (може било коjа имплеметациjа на стек да се искористи). Од влезната листа
коj содржи топчиња (topcinja) се поминува низ секое топче во листата и се прави
93
Податочни структури
следново: ако топчето е црвено (’R’), се проверува дали стекот crveni е празен
или не. Ако не е празен и горното топче на стекот е исто со тековното, тогаш се
додава на стекот. Во спротивно, се отстранува од стекот и се игнорира. Истото
се применува и за зелените (’G’) и сините (’B’) топчиња. По обработката на сите
топчиња треба да се отстранат топчињата од стековите во низа коjа ги содржи
отстранетите топчиња како текст во формат "Боjа Знак"каде знакот е + или -,
и се печати броjот на отстанети топчиња.
Имплементациjата на решението е дадена подолу. Резултатот од примерен
влез се печати на излез во главниот main метод.




public class Main {
    public static String ponistiTopcinja(List l) {
        ArrayStack<String> crveni = new ArrayStack<String>(100);
        ArrayStack<String> zeleni = new ArrayStack<String>(100);
        ArrayStack<String> sini = new ArrayStack<String>(100);
        String s;
        String izlez = new String();
        int n = 0;

        for (int i = 0; i < l.size(); i++) {
            s = (String) l.get(i);

            if (s.charAt(0) == 'R') {
                if (!crveni.isEmpty())
                    if (crveni.peek().equals(s))
                        crveni.push(s);
                    else
                        crveni.pop();
                else
                    crveni.push(s);
            }

            if (s.charAt(0) == 'G') {
                if (!zeleni.isEmpty())
                    if (zeleni.peek().equals(s))
                        zeleni.push(s);
                    else
                        zeleni.pop();
                else
                    zeleni.push(s);
            }

            if (s.charAt(0) == 'B') {
                if (!sini.isEmpty())
                    if (sini.peek().equals(s))
                        sini.push(s);
                    else
                        sini.pop();
                else
                    sini.push(s);
            }
        }

        while (!crveni.isEmpty()) {
            n++;
            if (crveni.pop().charAt(1) == '+')
                izlez += "R- ";
            else
                izlez += "R+ ";
        }
        while (!zeleni.isEmpty()) {
            n++;
            if (zeleni.pop().charAt(1) == '+')
                izlez += "G- ";
            else
                izlez += "G+ ";
        }
        while (!sini.isEmpty()) {
            n++;
            if (sini.pop().charAt(1) == '+')
                izlez += "B- ";
            else
                izlez += "B+ ";
        }

        System.out.println(n);

        return izlez;
    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String vlez[] = new String[100];
        vlez = br.readLine().split(" ");

        List<String> topcinja = new LinkedList<String>();
        for (int i = 0; i < vlez.length; i++)
            topcinja.add(vlez[i]);

        System.out.println(ponistiTopcinja(topcinja));
    }
}



Молекула на вода
Да се напише алгоритам со коj ´ке се имплементира играта “Направи молекула
на вода”. Во оваа игра на располагање имате два типа атоми (H-водород, и Oкислород). За да се направи молекула на вода (H2O) потребно е да имате два
атоми на водород и еден атом на кислород. На почеток се генерира една случаjна
секвенца од атоми. Ваша задача е од тоj влез, како доа´гаат атомите да генерирате
молекули и да кажете колку такви молекули се креирале, и кои атоми останале
несврзани.
Влез: Во влезот е дадена секвенца од случаjни атоми
Излез: На излез треба да се испечати броjот на молекули H2O, и несврзаните
атоми од водород и кислород.
Пример:
Влез:
H H O H H O H H O H H H H H O H O H O O H O O H H H
Излез:
8
H
96
Податочни структури
O
Решение
Во дадената задача треба да се имплементира обработка на атоми и креирање
на молекули, притоа се симулира споjување на водородни и кислородни атоми за
формирање вода (H2O) молекули. За да се одговори на барањата од задачата мора да се искористат два стека: vodorod и kislorod, кои се користат за да се чуваат
атомите со соодветните видови (водород и кислород) (може било коjа имплеметациjа на стек да се искористи). Од влезната листа коj содржи атоми (atomi) се
поминува низ секое атом во листата и се прави следново: Ако атомот е водород
("H"), се додава во стекот vodorod, а ако атомот е кислород ("O"), се додава во
стекот kislorod. Треба да се провери дали има доволно водородни и кислородни
атоми за создавање на водата (H2O). Доколку има доволно водородни и кислородни атоми, треба да се отстранат по два водородни и еден кислороден атом
од соодветните стекови, со зголемување на броjот на создадени молекули вода.
Доколку нема доволно водородни и кислородни атоми за да се создаде вода, операциjата се завршува. По обработката на сите атоми треба да се отстранат сите
останати водородни и кислородни атоми од стековите во низа коjа ги содржи
сите атоми како текст во формат "H"за водород и "O"за кислород, и се печати
броjот на создадените молекули на вода.
Имплементациjата на решението е дадена подолу. Резултатот од примерен
влез се печати на излез во главниот main метод.



public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int molekuli = 0;

        // Removed the unnecessary sc.nextLine()
        ArrayStack<String> vodorod = new ArrayStack<>(100); // Hydrogen stack
        ArrayStack<String> kislorod = new ArrayStack<>(100); // Oxygen stack

        String[] atoms = sc.nextLine().split(" ");

        for (String atom : atoms) {
            if(atom.equals("H")){
                vodorod.push(atom);
            } else if(atom.equals("O")){
                kislorod.push(atom);
            }

            while (vodorod.size() >= 2 && !kislorod.isEmpty()) {
                vodorod.pop();
                vodorod.pop();
                kislorod.pop();
                molekuli++;
            }
        }

        System.out.println(molekuli);
        System.out.println(kislorod.size());
        System.out.println(vodorod.size());
    }
}

