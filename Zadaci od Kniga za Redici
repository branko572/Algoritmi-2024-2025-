Возови
На една железничка станица дошло до расипување на еден воз. За да се искористат вагоните кои се во функционална состоjба, потребно е да се направи
прераспределување на истите за да се добие нов воз. Откачувањето на вагоните од расипаниот воз се прави еден по еден од страна на последниот вагон. На
истата шина во спротивна насока поставена е новата локомотива на коjа ´ке се
прикачуваат вагоните од стариот воз кои се во функционална состоjба (прикачувањето секогаш се врши на последниот вагон), т.е. со оваа нова локомотива
´ке прави новиот воз. Нека вагоните на расипаниот воз се обележани со сериски
броеви, освен оние кои се во нефункционална состоjба, тие се обележани се со 0.
При формирање на новиот воз треба да се внимава вагоните да бидат сортирани според сериските броеви и тоа во опа´гачки редослед, гледаj´ки од страна на
локомотивата.
За да се изврши прераспределба на вагоните се користи една помошна кружна
шина (паралелна на онаа каj што се поставени стариот и новиот воз). На оваа
помошна кружна шина вагоните се вадат по истиот редослед по коj се додаваат.
Вагоните кои излегуваат од оваа помошна шина може или да се прикачуваат на
новиот воз на краj, или на стариот воз на краj или на краjот на самата шина (т.е.
да се прередат од почеток на краj на истата шина зошто е кружна). Вагоните од
стариот воз (кои се откачуваат) може да се прикачуваат на краj на помошната
шина или на краj на новиот воз. Истото важи и за вагоните на новиот воз. Ваша
задача е да направите алгоритам коj што ´ке го формира новиот воз со вагони во
функционална состоjба.
Влез: Во влезот е даден прво се вкупниот броj на вагони на расипаниот воз.
Следно се дава во секоj нареден ред соодветно сериските броеви на вагоните од
расипаниот воз.
Излез: На излез треба да се испечати состоjбата на новиот воз со сериските
броеви (почнуваj´ки од последниот вагон).
Пример:
Влез:
30
55
100
44
33
0
0
22
125
5
11
8
60
4
21
90
12
56
108
404
3
0
0
22
0
110
0
6
0
17
0
71
Излез:
3 4 5 6 8 11 12 17 21 22 22 33 44 55 56 60 71 90 100 108 110 404


public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        sc.nextLine();
        ArrayQueue<Integer> q = new ArrayQueue<>(N);
        for (int i = 0; i < N; i++) {
            q.enqueue(sc.nextInt());
        }

        Integer[] temp = new Integer[N];
        for (int i = 0; i < N; i++) {
            temp[i] = q.dequeue();
        }

        Arrays.sort(temp);

        for(Integer i : temp){
            q.enqueue(i);
        }
        while (!q.isEmpty()) {
            int n = q.dequeue();
            if(n != 0){
                System.out.print(n + " ");  // Use 'n', not q.dequeue()
            }
        }

    }
}


Напредни проблеми со редица
Задача 1. Колоквиум
Се организира прв колоквиум по предметот Алгоритми и структури на податоци.
За таа цел се отвара анкета по предметот на коjа студентите се приjавуваат.
Анкетата има дадено 2 избори:
1) Полагам во било коj термин
2) Испитот ми се преклопува со Математика
Студентите се поставуваат во термините според редоследите во кои се примени (почнуваj´ки од првиот). Сите студенти сакаат да полагаат колку е можно
порано па затоа дел од студентите мамат и во анкетата наведуваат дека истиот
ден полагаат и Математика. Асистентите бараат список на студенти кои полагаат Математика и добиваат. Потоа се започнува со распределба на студентите
во термини: прво во термините се доделуваат студентите кои се приjавиле дека
полагаат и Математика (по редоследот по коj се приjавиле), ме´гутоа секоj од
овие студенти се проверува дали навистина полага и Математика и ако мамел
се сместува на краj од списокот на студенти кои избрале дека полагаат било коj
термин. Потоа се изминуваат останатите студенти и се доделуваат во термини.
Влез: Во влезот е даден прво капацитетот на студенти по термин (т.е. по колку студенти во еден термин може да полагаат). Следно се дава броjот и списокот
на студенти кои истиот ден полагаат и Математика (според редоследот по коj
се приjавиле). Потоа се дава броjот и списокот на останатите студенти (според
редоследот по коj се приjавиле). На краj се дава броj и список на студенти кои
навистина полагаат Математика.
Излез: На излез треба да се испечати броj на термин, па студентите кои
полагаат во тоj термин.
Пример:
Влез:
2
4
IlinkaIvanoska
IgorKulev
129
Податочни структури
MagdalenaKostoska
HristinaMihajloska
3
VladimirTrajkovik
SlobodanKalajdziski
AnastasMisev
1
IlinkaIvanoska
Излез: 1
IlinkaIvanoska
VladimirTrajkovik
2
SlobodanKalajdziski
AnastasMisev
3
IgorKulev
MagdalenaKostoska
4
HristinaMihajloska
Решение
Во дадената задача треба да се имплементира распределба на полагање на студенти на прв колоквиум по предметот Алгоритми и структури на податоци по
термини. За да се одговори на барањата од задачата мора да се искористат 2
податочни структури редица (redMath и redOstanati) за да се чуваат студентите
соодветно според тоа што се приjавиле дека полагаат (АПС и Математика, или
пак само АПС) (може било коjа имплеметациjа на редица да се искористи). На
влезот коj се обработува дадени се броjот на студенти за распределва по термин,
броj на студенти кои исто така полагаат и Математика во истиот термин како и
колоквиумот по АПС, како и нивните имиња кои се ставаат во соодветната редица, па броjот на студенти кои полагаат само колоквиум по АПС, без Математика,
како и нивните имиња кои со кои се пони втората редица. Потоа, се дава броjот
на студенти кои вистински полагаат Математика, како и нивните имиња за кои
мора да се искористи дополнителна податочна структура да се зачуваат како
листа listRealMath. Распределба на студентите се прави според следните услови:
Студентите од redMath се проверува дали се вистински приjавени за Математика, и ако не се во listRealMath, тогаш се преместуваат во redOstanati. Потоа,
студентите се распределуваат во термините. Во секоj термин се додаваат студен130
Податочни структури
ти онолку колку е дозволено, ако има достапни студенти во redMath. Ако нема
пове´ке студенти во redMath, се користи redOstanati за дополнително пополнување на термините. Накраj, за секоj термин се прикажува листата на студенти кои
се приjавиле за тоj термин.
Имплементациjата на решението е дадена подолу. Резултатот од примерен
влез се печати на излез во главниот main метод



public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Read input
        int capacity = Integer.parseInt(sc.nextLine().trim());
        int nMath = Integer.parseInt(sc.nextLine().trim());
        ArrayQueue<String> queue = new ArrayQueue<>(nMath); // Size based on input
        for (int i = 0; i < nMath; i++) {
            queue.enqueue(sc.nextLine());
        }

        int rest = Integer.parseInt(sc.nextLine().trim());
        ArrayQueue<String> queue2 = new ArrayQueue<>(rest + nMath); // Add capacity for potential transfers
        for (int i = 0; i < rest; i++) {
            queue2.enqueue(sc.nextLine());
        }

        int real = Integer.parseInt(sc.nextLine().trim());
        List<String> queue3 = new ArrayList<>(); // Use List for easier membership check
        for (int i = 0; i < real; i++) {
            queue3.add(sc.nextLine());
        }

        // Separate real math students from those who only claim
        ArrayQueue<String> verifiedMath = new ArrayQueue<>(nMath);
        while (!queue.isEmpty()) {
            String student = queue.dequeue();
            if (queue3.contains(student)) {
                verifiedMath.enqueue(student); // verified student
            } else {
                queue2.enqueue(student); // transfer to other queue
            }
        }

        // Process exam slots
        int brojTermin = 1;
        while (!verifiedMath.isEmpty() || !queue2.isEmpty()) {
            System.out.println(brojTermin);
            int counter = 0;

            // Assign math students first
            while (counter < capacity && !verifiedMath.isEmpty()) {
                System.out.println(verifiedMath.dequeue());
                counter++;
            }

            // Fill remaining slots with other students
            while (counter < capacity && !queue2.isEmpty()) {
                System.out.println(queue2.dequeue());
                counter++;
            }

            brojTermin++;
        }
    }
}
