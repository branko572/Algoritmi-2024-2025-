Во следната задача треба да изградите неподредено (општо) дрво со N јазли, за кое ќе треба да одговорите на Q прашања од видот „колку лисја има поддрвото на избран јазол“.

Секој јазол ќе има уникатен индекс од 1 до N. Коренот на дрвото секогаш ќе има индекс 1. Сите деца ќе имаат индекси поголеми од индексите на родителите.

Влезот ќе содржи N+Q редови од видот 

root 1 - Треба да го поставите коренот на дрвото да биде јазелот со индекс 1

add parent_index child_index - Треба да додадете дете јазел со индекс child_index на јазелот со индекс parent_index

ask node_index - Треба да одговорите колку листови има во поддрвото на јазелот со индекс node_index

Пример и структура на влезот:

Влез

Објаснување

Излез

11 5
root 1
add 1 2
add 2 3
ask 1
add 1 4
add 2 5
add 3 6
ask 2
add 3 7
ask 1
add 1 8
add 4 9
add 2 10
add 4 11
ask 2
ask 1

Прикажано е изгледот на дрвото при секое од 5те прашања во влезот

прашање 1



прашање 1: ask 1: Во поддрвото на јазелот 1 има 1 лист.
прашање 2: ask 2: Во поддрвото на јазелот 2 има 2 листови.
прашање 3: ask 1: Во поддрвото на јазелот 1 има 4 листови.
прашање 4: ask 2: Во поддрвото на јазелот 2 има 4 листови
прашање 5: ask 1: Во поддрвото на јазелот 1 има 7 листови
1
2
4
4
7



------


In the following task you need to build an unordered (general) tree with N nodes, for which you will need to answer Q questions of the type "how many leaves does the subtree of a selected node have".

Each node will have a unique index from 1 to N. The root of the tree will always have an index 1. All children will have indices greater than the parent indices.

The input will contain N+Q rows of the type

root 1 - You need to set the root of the tree to be the node with index 1

add parent_index child_index - You need to add a child node with index child_index to the node with index parent_index

ask node_index - You need to answer how many leaves are in the subtree of the node with index node_index

Example and structure of the input:

Input

Explanation

Output

11 5
root 1
add 1 2
add 2 3
ask 1
add 1 4
add 2 5
add 3 6
ask 2
add 3 7
ask 1
add 1 8
add 4 9
add 2 10
add 4 11
ask 2
ask 1

The tree view is shown for each of the 5 questions in the input

question 1


question 1: ask 1: In the subtree of node 1 there is 1 leaf.
question 2: ask 2: In the subtree of node 2 there are 2 leaves.
question 3: ask 1: In the subtree of node 1 there are 4 leaves.
Question 4: ask 2: In the subtree of node 2 there are 4 leaves
Question 5: ask 1: In the subtree of node 1 there are 7 sheets
1
2
4
4
7

For example:

Input	Result
11 5
root 1
add 1 2
add 2 3
ask 1
add 1 4
add 2 5
add 3 6
ask 2
add 3 7
ask 1
add 1 8
add 4 9
add 2 10
add 4 11
ask 2
ask 1
1
2
4
4
7





import java.util.*;

public class Main {
    
    static Map<Integer, List<Integer>> tree = new HashMap<>();

    
    static int countLeaves(int node) {
        
        if (!tree.containsKey(node) || tree.get(node).isEmpty()) {
            return 1;
        }
        int leaves = 0;
          
        for (int child : tree.get(node)) {
            leaves += countLeaves(child);
        }
        return leaves;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        
        int N = sc.nextInt();
        int Q = sc.nextInt();
        sc.nextLine(); 

        
        for (int i = 0; i < N + Q; i++) {
            String command = sc.nextLine();
            String[] parts = command.split(" ");

            if (parts[0].equals("root")) {
                
                int root = Integer.parseInt(parts[1]);
                tree.put(root, new ArrayList<>());
            } else if (parts[0].equals("add")) {
                
                int parent = Integer.parseInt(parts[1]);
                int child = Integer.parseInt(parts[2]);
                tree.computeIfAbsent(parent, k -> new ArrayList<>()).add(child);
            } else if (parts[0].equals("ask")) {
                
                int node = Integer.parseInt(parts[1]);
                System.out.println(countLeaves(node));
            }
        }

        sc.close();
    }
}




Во следната задача треба да изградите бинарно дрво со N јазли, за кое ќе треба да одговорите на Q прашања од видот „која е максималната длабочина во поддрвото на избран јазол“.

Секој јазол ќе има уникатно име. Името на коренот на дрвото секогаш ќе ви биде дадено прво. 

Влезот ќе содржи N+Q редови од видот

root ime - Треба да го поставите коренот на дрвото да биде јазелот со име ime

add parent_name child_name - Треба да додадете дете јазел со име child_name на јазелот со име parent_name

ask node_name - Треба да го одговориме прашањето за поддрвото на јазелот со име node_name

Пример и структура на влезот:

Влез

Објаснување

Излез

11 9
root bravo
add bravo echo LEFT
add echo beard LEFT
ask beard
ask bravo
add bravo foxtrot RIGHT
add beard hotel LEFT
add beard india RIGHT
ask echo
add foxtrot golf LEFT
add golf juliet RIGHT
add india sierra RIGHT
ask foxtrot
ask bravo
ask beard
add echo mike RIGHT
add foxtrot tango RIGHT
ask echo
ask bravo
ask foxtrot	
Прикажано е изгледот на дрвото при секоја од 4те групи прашања во влезот




1
3
3
3
5
3
4
5
3



------



In the following task, you need to build a binary tree with N nodes, for which you will need to answer Q questions of the type "what is the maximum depth in the subtree of a selected node"..

Each node will have a unique name. The name of the root of the tree will always be given to you first.

The input will contain N+Q rows of the type

root name - You need to set the root of the tree to be the node named name

add parent_name child_name - You need to add a child node named child_name to the node named parent_name

ask node_name - We need to answer the question about the subtree of the node named node_name

Example and structure of the input:

Input

Explanation

Output

11 9
root bravo
add bravo echo LEFT
add echo beard LEFT
ask beard
ask bravo
add bravo foxtrot RIGHT
add beard hotel LEFT
add beard india RIGHT
ask echo
add foxtrot golf LEFT
add golf juliet RIGHT
add india sierra RIGHT
ask foxtrot
ask bravo
ask beard
add echo mike RIGHT
add foxtrot tango RIGHT
ask echo
ask bravo
ask foxtrot	
The tree layout is shown for each of the 4 groups of questions in the sample input.




1
3
3
3
5
3
4
5
3

For example:

Input	Result
11 9
root bravo
add bravo echo LEFT
add echo beard LEFT
ask beard
ask bravo
add bravo foxtrot RIGHT
add beard hotel LEFT
add beard india RIGHT
ask echo
add foxtrot golf LEFT
add golf juliet RIGHT
add india sierra RIGHT
ask foxtrot
ask bravo
ask beard
add echo mike RIGHT
add foxtrot tango RIGHT
ask echo
ask bravo
ask foxtrot
1
3
3
3
5
3
4
5
3


import java.util.*;

class TreeNode {
    String name;
    TreeNode left, right;

    TreeNode(String name) {
        this.name = name;
        this.left = null;
        this.right = null;
    }
}

public class Main {

    static Map<String, TreeNode> tree = new HashMap<>();

    // Функција за наоѓање на максимална длабочина
    static int maxdepth(TreeNode root) {
        if (root == null) return 0;
        int left = maxdepth(root.left);
        int right = maxdepth(root.right);
        return Math.max(left, right) + 1;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();  // Број на јазли
        int Q = sc.nextInt();  // Број на прашања
        sc.nextLine();  // Да се исчисти новиот ред после nextInt()

        for (int i = 0; i < N + Q; i++) {
            String command = sc.nextLine();
            String[] parts = command.split(" ");

            if (parts[0].equals("root")) {
                // Креирање на коренот
                String rootName = parts[1];
                tree.put(rootName, new TreeNode(rootName));
            } else if (parts[0].equals("add")) {
                // Додавање на дете
                String parentName = parts[1];
                String childName = parts[2];
                String position = parts[3];

                TreeNode parentNode = tree.get(parentName);
                if (parentNode != null) {
                    TreeNode childNode = new TreeNode(childName);
                    if (position.equals("LEFT")) {
                        parentNode.left = childNode;
                    } else if (position.equals("RIGHT")) {
                        parentNode.right = childNode;
                    }
                    tree.put(childName, childNode);  // Додади го детето во мапата
                }
            } else if (parts[0].equals("ask")) {
                // Прашање за максимална длабочина
                String nodeName = parts[1];
                TreeNode node = tree.get(nodeName);
                if (node != null) {
                    System.out.println(maxdepth(node));
                } else {
                    System.out.println(0);  // Ако јазелот не постои, врати 0
                }
            }
        }

        sc.close();  // Затвори го Scanner надвор од јамката
    }
}






