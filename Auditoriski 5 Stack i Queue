DOUBLE ARRAY STACK ZADACA KAKO BI IZGLEDALA


import java.util.*;

class DoubleArrayStack<E> {

    private E[] elems;
    private int top1;
    private int top2;

    @SuppressWarnings("unchecked")
    public DoubleArrayStack(int maxDepth) {
        elems = (E[]) new Object[maxDepth];
        top1 = -1;
        top2 = maxDepth;
    }

    public boolean isFull() {
        return (top1 + 1 == top2);
    }

    public boolean isEmptyFirst() {
        return top1 == -1;
    }

    public boolean isEmptySecond() {
        return top2 == elems.length;
    }

    public void clearFirst() {
        while (!isEmptyFirst()) {
            elems[top1--] = null;
        }
    }

    public void clearSecond() {
        while (!isEmptySecond()) {
            elems[top2++] = null;
        }
    }

    public E peekFirst() {
        if (isEmptyFirst())
            return null;
        return elems[top1];
    }

    public E peekSecond() {
        if (isEmptySecond())
            return null;
        return elems[top2];
    }

    public void pushFirst(E x) {
        if (isFull()) {
            throw new RuntimeException("Stack Overflow");
        }
        elems[++top1] = x;
    }

    public void pushSecond(E x) {
        if (isFull()) {
            throw new RuntimeException("Stack Overflow");
        }
        elems[--top2] = x;
    }

    public E popFirst() {
        if (isEmptyFirst())
            return null;
        E topmost = elems[top1];
        elems[top1--] = null;
        return topmost;
    }

    public E popSecond() {
        if (isEmptySecond())
            return null;
        E topmost = elems[top2];
        elems[top2++] = null;
        return topmost;
    }

    @Override
    public String toString() {
        return Arrays.toString(elems);
    }
}
public class Main {
    public static void main(String[] args) {
        DoubleArrayStack<Integer> stack = new DoubleArrayStack<>(10);

        // Push to both stacks
        stack.pushFirst(1);
        stack.pushFirst(2);
        stack.pushFirst(3);

        stack.pushSecond(99);
        stack.pushSecond(98);
        stack.pushSecond(97);

        // Show full array state
        System.out.println("Stack contents: " + stack);

        // Peek
        System.out.println("Top of First Stack: " + stack.peekFirst());  // 3
        System.out.println("Top of Second Stack: " + stack.peekSecond()); // 97

        // Pop
        System.out.println("Pop from First Stack: " + stack.popFirst()); // 3
        System.out.println("Pop from Second Stack: " + stack.popSecond()); // 97

        // Show state after pop
        System.out.println("After pop - Stack contents: " + stack);

        // Clear both
        stack.clearFirst();
        stack.clearSecond();
        System.out.println("After clear - Stack contents: " + stack);
    }
}



Задача 1.
• Да се провери коректноста на заградите во еден израз.
• Еден израз има коректни загради ако:
– За секоја лева заграда, подоцна следува соодветна десна заграда
– За секоја десна заграда претходно постои лева заграда
– Секој под-израз меѓу пар од две загради содржи коректен број на
загради
• Примери на изрази со коректни и некоректни загради:
s  (s – a)  (s – b)  (s – c)
(– b + [b
2 – 4ac]) / 2a
s  (s – a)  (s – b  (s – c)
s  (s – a)  s – b)  (s – c)
(– b + [b
2 – 4ac)] / 2


import java.util.*;

interface Stack<E> {
    public boolean isEmpty();
    public E peek();
    public void clear();
    public void push(E x);
    public E pop();
}

class ArrayStack<E> implements Stack<E> {
    private E[] elems;
    private int depth;

    @SuppressWarnings("unchecked")
    public ArrayStack(int maxDepth) {
        elems = (E[]) new Object[maxDepth];
        depth = 0;
    }

    public boolean isEmpty() {
        return (depth == 0);
    }

    public E peek() {
        if (depth == 0)
            throw new NoSuchElementException();
        return elems[depth - 1];
    }

    public void clear() {
        for (int i = 0; i < depth; i++) elems[i] = null;
        depth = 0;
    }

    public void push(E x) {
        elems[depth++] = x;
    }

    public int size() {
        return depth;
    }

    public E pop() {
        if (depth == 0)
            throw new NoSuchElementException();
        E topmost = elems[--depth];
        elems[depth] = null;
        return topmost;
    }
}

public class Main {

    public static boolean matching(char left, char right) {
        return (left == '(' && right == ')') ||
                (left == '[' && right == ']') ||
                (left == '{' && right == '}');
    }

    public static boolean isCorrect(String expression) {
        ArrayStack<Character> brackets = new ArrayStack<>(expression.length());

        for (int i = 0; i < expression.length(); i++) {
            char ch = expression.charAt(i);

            if (ch == '(' || ch == '{' || ch == '[') {
                brackets.push(ch);
            } else if (ch == ')' || ch == '}' || ch == ']') {
                if (brackets.isEmpty()) {
                    return false;
                }
                char leftBracket = brackets.pop();
                if (!matching(leftBracket, ch)) {
                    return false;
                }
            }
        }

        return brackets.isEmpty();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String expression = scanner.nextLine();
        System.out.println(isCorrect(expression));
    }
}



Задача 2.
• ЗА ДОМА. Да се напише алгоритам кој ќе врши евалуација
на израз во постфикс нотација.
• Пр. 5 9 + 2 * 6 5 * + изразот е во постфикс нотација 





import java.util.*;

interface Stack<E> {
    public boolean isEmpty();
    public E peek();
    public void clear();
    public void push(E x);
    public E pop();
}

class ArrayStack<E> implements Stack<E> {
    private E[] elems;
    private int depth;

    @SuppressWarnings("unchecked")
    public ArrayStack(int maxDepth) {
        elems = (E[]) new Object[maxDepth];
        depth = 0;
    }

    public boolean isEmpty() {
        return (depth == 0);
    }

    public E peek() {
        if (depth == 0)
            throw new NoSuchElementException();
        return elems[depth - 1];
    }

    public void clear() {
        for (int i = 0; i < depth; i++) elems[i] = null;
        depth = 0;
    }

    public void push(E x) {
        elems[depth++] = x;
    }

    public int size() {
        return depth;
    }

    public E pop() {
        if (depth == 0)
            throw new NoSuchElementException();
        E topmost = elems[--depth];
        elems[depth] = null;
        return topmost;
    }
}

public class Main {

    public static int resultPostfix(char[] a){
        ArrayStack<Integer>stack=new ArrayStack<>(100);
        int number=0;
        for(int i=0;i<a.length;i++){
            if(Character.isDigit(a[i]) && Character.isDigit(a[i+1])){
            number=number*10+Character.getNumericValue(a[i]);
            }
            if(Character.isDigit(a[i]) && !Character.isDigit(a[i+1])){
                number=number*10+Character.getNumericValue(a[i]);
                stack.push(number);
                number=0;
            }

            if(a[i]=='+' || a[i]=='-' || a[i]=='*' || a[i]=='/'){
                int num1=stack.pop();
                int num2=stack.pop();

                if(a[i]=='+'){
                    stack.push(num1+num2);
                }
                else if(a[i]=='-'){
                    stack.push(num1-num2);
                }
                else if(a[i]=='*'){
                    stack.push(num1*num2);
                }
                else if(a[i]=='/'){
                    stack.push(num1/num2);
                }
            }
        }
        return stack.pop();
    }




    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s1= sc.nextLine();
        char[] c= s1.toCharArray();
        int result =Main.resultPostfix(c);
        System.out.println(result);
    }
}



Задача 3.
• Студентската служба на факултет работи со студенти од
09:00 до 12:00. Ако знаеме за секој студент од редицата
колку време е потребно за студентската служба да го
опслужи, да се одреди кој студент ќе биде првиот студент
кој нема да биде опслужен и колку студенти што чекале во
редицата за тој ден не се опслужени.

