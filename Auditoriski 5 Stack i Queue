DOUBLE ARRAY STACK ZADACA KAKO BI IZGLEDALA


import java.util.*;

class DoubleArrayStack<E> {

    private E[] elems;
    private int top1;
    private int top2;

    @SuppressWarnings("unchecked")
    public DoubleArrayStack(int maxDepth) {
        elems = (E[]) new Object[maxDepth];
        top1 = -1;
        top2 = maxDepth;
    }

    public boolean isFull() {
        return (top1 + 1 == top2);
    }

    public boolean isEmptyFirst() {
        return top1 == -1;
    }

    public boolean isEmptySecond() {
        return top2 == elems.length;
    }

    public void clearFirst() {
        while (!isEmptyFirst()) {
            elems[top1--] = null;
        }
    }

    public void clearSecond() {
        while (!isEmptySecond()) {
            elems[top2++] = null;
        }
    }

    public E peekFirst() {
        if (isEmptyFirst())
            return null;
        return elems[top1];
    }

    public E peekSecond() {
        if (isEmptySecond())
            return null;
        return elems[top2];
    }

    public void pushFirst(E x) {
        if (isFull()) {
            throw new RuntimeException("Stack Overflow");
        }
        elems[++top1] = x;
    }

    public void pushSecond(E x) {
        if (isFull()) {
            throw new RuntimeException("Stack Overflow");
        }
        elems[--top2] = x;
    }

    public E popFirst() {
        if (isEmptyFirst())
            return null;
        E topmost = elems[top1];
        elems[top1--] = null;
        return topmost;
    }

    public E popSecond() {
        if (isEmptySecond())
            return null;
        E topmost = elems[top2];
        elems[top2++] = null;
        return topmost;
    }

    @Override
    public String toString() {
        return Arrays.toString(elems);
    }
}
public class Main {
    public static void main(String[] args) {
        DoubleArrayStack<Integer> stack = new DoubleArrayStack<>(10);

        // Push to both stacks
        stack.pushFirst(1);
        stack.pushFirst(2);
        stack.pushFirst(3);

        stack.pushSecond(99);
        stack.pushSecond(98);
        stack.pushSecond(97);

        // Show full array state
        System.out.println("Stack contents: " + stack);

        // Peek
        System.out.println("Top of First Stack: " + stack.peekFirst());  // 3
        System.out.println("Top of Second Stack: " + stack.peekSecond()); // 97

        // Pop
        System.out.println("Pop from First Stack: " + stack.popFirst()); // 3
        System.out.println("Pop from Second Stack: " + stack.popSecond()); // 97

        // Show state after pop
        System.out.println("After pop - Stack contents: " + stack);

        // Clear both
        stack.clearFirst();
        stack.clearSecond();
        System.out.println("After clear - Stack contents: " + stack);
    }
}



–ó–∞–¥–∞—á–∞ 1.
‚Ä¢ –î–∞ —Å–µ –ø—Ä–æ–≤–µ—Ä–∏ –∫–æ—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∞ –Ω–∞ –∑–∞–≥—Ä–∞–¥–∏—Ç–µ –≤–æ –µ–¥–µ–Ω –∏–∑—Ä–∞–∑.
‚Ä¢ –ï–¥–µ–Ω –∏–∑—Ä–∞–∑ –∏–º–∞ –∫–æ—Ä–µ–∫—Ç–Ω–∏ –∑–∞–≥—Ä–∞–¥–∏ –∞–∫–æ:
‚Äì –ó–∞ —Å–µ–∫–æ—ò–∞ –ª–µ–≤–∞ –∑–∞–≥—Ä–∞–¥–∞, –ø–æ–¥–æ—Ü–Ω–∞ —Å–ª–µ–¥—É–≤–∞ —Å–æ–æ–¥–≤–µ—Ç–Ω–∞ –¥–µ—Å–Ω–∞ –∑–∞–≥—Ä–∞–¥–∞
‚Äì –ó–∞ —Å–µ–∫–æ—ò–∞ –¥–µ—Å–Ω–∞ –∑–∞–≥—Ä–∞–¥–∞ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–æ –ø–æ—Å—Ç–æ–∏ –ª–µ–≤–∞ –∑–∞–≥—Ä–∞–¥–∞
‚Äì –°–µ–∫–æ—ò –ø–æ–¥-–∏–∑—Ä–∞–∑ –º–µ—ì—É –ø–∞—Ä –æ–¥ –¥–≤–µ –∑–∞–≥—Ä–∞–¥–∏ —Å–æ–¥—Ä–∂–∏ –∫–æ—Ä–µ–∫—Ç–µ–Ω –±—Ä–æ—ò –Ω–∞
–∑–∞–≥—Ä–∞–¥–∏
‚Ä¢ –ü—Ä–∏–º–µ—Ä–∏ –Ω–∞ –∏–∑—Ä–∞–∑–∏ —Å–æ –∫–æ—Ä–µ–∫—Ç–Ω–∏ –∏ –Ω–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏ –∑–∞–≥—Ä–∞–¥–∏:
s ÔÇ¥ (s ‚Äì a) ÔÇ¥ (s ‚Äì b) ÔÇ¥ (s ‚Äì c)
(‚Äì b + ÔÉñ[b
2 ‚Äì 4ac]) / 2a
s ÔÇ¥ (s ‚Äì a) ÔÇ¥ (s ‚Äì b ÔÇ¥ (s ‚Äì c)
s ÔÇ¥ (s ‚Äì a) ÔÇ¥ s ‚Äì b) ÔÇ¥ (s ‚Äì c)
(‚Äì b + ÔÉñ[b
2 ‚Äì 4ac)] / 2


import java.util.*;

interface Stack<E> {
    public boolean isEmpty();
    public E peek();
    public void clear();
    public void push(E x);
    public E pop();
}

class ArrayStack<E> implements Stack<E> {
    private E[] elems;
    private int depth;

    @SuppressWarnings("unchecked")
    public ArrayStack(int maxDepth) {
        elems = (E[]) new Object[maxDepth];
        depth = 0;
    }

    public boolean isEmpty() {
        return (depth == 0);
    }

    public E peek() {
        if (depth == 0)
            throw new NoSuchElementException();
        return elems[depth - 1];
    }

    public void clear() {
        for (int i = 0; i < depth; i++) elems[i] = null;
        depth = 0;
    }

    public void push(E x) {
        elems[depth++] = x;
    }

    public int size() {
        return depth;
    }

    public E pop() {
        if (depth == 0)
            throw new NoSuchElementException();
        E topmost = elems[--depth];
        elems[depth] = null;
        return topmost;
    }
}

public class Main {

    public static boolean matching(char left, char right) {
        return (left == '(' && right == ')') ||
                (left == '[' && right == ']') ||
                (left == '{' && right == '}');
    }

    public static boolean isCorrect(String expression) {
        ArrayStack<Character> brackets = new ArrayStack<>(expression.length());

        for (int i = 0; i < expression.length(); i++) {
            char ch = expression.charAt(i);

            if (ch == '(' || ch == '{' || ch == '[') {
                brackets.push(ch);
            } else if (ch == ')' || ch == '}' || ch == ']') {
                if (brackets.isEmpty()) {
                    return false;
                }
                char leftBracket = brackets.pop();
                if (!matching(leftBracket, ch)) {
                    return false;
                }
            }
        }

        return brackets.isEmpty();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String expression = scanner.nextLine();
        System.out.println(isCorrect(expression));
    }
}



–ó–∞–¥–∞—á–∞ 2.
‚Ä¢ –ó–ê –î–û–ú–ê. –î–∞ —Å–µ –Ω–∞–ø–∏—à–µ –∞–ª–≥–æ—Ä–∏—Ç–∞–º –∫–æ—ò —ú–µ –≤—Ä—à–∏ –µ–≤–∞–ª—É–∞—Ü–∏—ò–∞
–Ω–∞ –∏–∑—Ä–∞–∑ –≤–æ –ø–æ—Å—Ç—Ñ–∏–∫—Å –Ω–æ—Ç–∞—Ü–∏—ò–∞.
‚Ä¢ –ü—Ä. 5 9 + 2 * 6 5 * + –∏–∑—Ä–∞–∑–æ—Ç –µ –≤–æ –ø–æ—Å—Ç—Ñ–∏–∫—Å –Ω–æ—Ç–∞—Ü–∏—ò–∞ 





import java.util.*;

interface Stack<E> {
    public boolean isEmpty();
    public E peek();
    public void clear();
    public void push(E x);
    public E pop();
}

class ArrayStack<E> implements Stack<E> {
    private E[] elems;
    private int depth;

    @SuppressWarnings("unchecked")
    public ArrayStack(int maxDepth) {
        elems = (E[]) new Object[maxDepth];
        depth = 0;
    }

    public boolean isEmpty() {
        return (depth == 0);
    }

    public E peek() {
        if (depth == 0)
            throw new NoSuchElementException();
        return elems[depth - 1];
    }

    public void clear() {
        for (int i = 0; i < depth; i++) elems[i] = null;
        depth = 0;
    }

    public void push(E x) {
        elems[depth++] = x;
    }

    public int size() {
        return depth;
    }

    public E pop() {
        if (depth == 0)
            throw new NoSuchElementException();
        E topmost = elems[--depth];
        elems[depth] = null;
        return topmost;
    }
}

public class Main {

    public static int resultPostfix(char[] a){
        ArrayStack<Integer>stack=new ArrayStack<>(100);
        int number=0;
        for(int i=0;i<a.length;i++){
            if(Character.isDigit(a[i]) && Character.isDigit(a[i+1])){
            number=number*10+Character.getNumericValue(a[i]);
            }
            if(Character.isDigit(a[i]) && !Character.isDigit(a[i+1])){
                number=number*10+Character.getNumericValue(a[i]);
                stack.push(number);
                number=0;
            }

            if(a[i]=='+' || a[i]=='-' || a[i]=='*' || a[i]=='/'){
                int num1=stack.pop();
                int num2=stack.pop();

                if(a[i]=='+'){
                    stack.push(num1+num2);
                }
                else if(a[i]=='-'){
                    stack.push(num1-num2);
                }
                else if(a[i]=='*'){
                    stack.push(num1*num2);
                }
                else if(a[i]=='/'){
                    stack.push(num1/num2);
                }
            }
        }
        return stack.pop();
    }




    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s1= sc.nextLine();
        char[] c= s1.toCharArray();
        int result =Main.resultPostfix(c);
        System.out.println(result);
    }
}



–ó–∞–¥–∞—á–∞ 3.
‚Ä¢ –°—Ç—É–¥–µ–Ω—Ç—Å–∫–∞—Ç–∞ —Å–ª—É–∂–±–∞ –Ω–∞ —Ñ–∞–∫—É–ª—Ç–µ—Ç —Ä–∞–±–æ—Ç–∏ —Å–æ —Å—Ç—É–¥–µ–Ω—Ç–∏ –æ–¥
09:00 –¥–æ 12:00. –ê–∫–æ –∑–Ω–∞–µ–º–µ –∑–∞ —Å–µ–∫–æ—ò —Å—Ç—É–¥–µ–Ω—Ç –æ–¥ —Ä–µ–¥–∏—Ü–∞—Ç–∞
–∫–æ–ª–∫—É –≤—Ä–µ–º–µ –µ –ø–æ—Ç—Ä–µ–±–Ω–æ –∑–∞ —Å—Ç—É–¥–µ–Ω—Ç—Å–∫–∞—Ç–∞ —Å–ª—É–∂–±–∞ –¥–∞ –≥–æ
–æ–ø—Å–ª—É–∂–∏, –¥–∞ —Å–µ –æ–¥—Ä–µ–¥–∏ –∫–æ—ò —Å—Ç—É–¥–µ–Ω—Ç —ú–µ –±–∏–¥–µ –ø—Ä–≤–∏–æ—Ç —Å—Ç—É–¥–µ–Ω—Ç
–∫–æ—ò –Ω–µ–º–∞ –¥–∞ –±–∏–¥–µ –æ–ø—Å–ª—É–∂–µ–Ω –∏ –∫–æ–ª–∫—É —Å—Ç—É–¥–µ–Ω—Ç–∏ —à—Ç–æ —á–µ–∫–∞–ª–µ –≤–æ
—Ä–µ–¥–∏—Ü–∞—Ç–∞ –∑–∞ —Ç–æ—ò –¥–µ–Ω –Ω–µ —Å–µ –æ–ø—Å–ª—É–∂–µ–Ω–∏.



import java.util.*;

class ArrayQueue<E> {
    // Redicata e pretstavena na sledniot nacin:
    // length go sodrzi brojot na elementi.
    // Ako length > 0, togash elementite na redicata se zachuvani vo elems[front...rear-1]
    // Ako rear > front, togash vo  elems[front...maxlength-1] i elems[0...rear-1]
    E[] elems;
    int length, front, rear;

    // Konstruktor ...

    @SuppressWarnings("unchecked")
    public ArrayQueue(int maxlength) {
        elems = (E[]) new Object[maxlength];
        clear();
    }

    public boolean isEmpty() {
        // Vrakja true ako i samo ako redicata e prazena.
        return (length == 0);
    }

    public int size() {
        // Ja vrakja dolzinata na redicata.
        return length;
    }

    public E peek() {
        // Go vrakja elementot na vrvot t.e. pocetokot od redicata.
        if (length > 0)
            return elems[front];
        else
            throw new NoSuchElementException();
    }

    public void clear() {
        // Ja prazni redicata.
        length = 0;
        front = rear = 0;  // arbitrary
    }

    public void enqueue(E x) {
        // Go dodava x na kraj od redicata.
        if (length == elems.length)
            throw new NoSuchElementException();
        elems[rear++] = x;
        if (rear == elems.length) rear = 0;
        length++;
    }

    public E dequeue() {
        // Go otstranuva i vrakja pochetniot element na redicata.
        if (length > 0) {
            E frontmost = elems[front];
            elems[front++] = null;
            if (front == elems.length) front = 0;
            length--;
            return frontmost;
        } else
            throw new NoSuchElementException();
    }
}

//–°—Ç—É–¥–µ–Ω—Ç—Å–∫–∞—Ç–∞ —Å–ª—É–∂–±–∞ –Ω–∞ —Ñ–∞–∫—É–ª—Ç–µ—Ç —Ä–∞–±–æ—Ç–∏ —Å–æ —Å—Ç—É–¥–µ–Ω—Ç–∏ –æ–¥
//09:00 –¥–æ 12:00. –ê–∫–æ –∑–Ω–∞–µ–º–µ –∑–∞ —Å–µ–∫–æ—ò —Å—Ç—É–¥–µ–Ω—Ç –æ–¥ —Ä–µ–¥–∏—Ü–∞—Ç–∞
//–∫–æ–ª–∫—É –≤—Ä–µ–º–µ –µ –ø–æ—Ç—Ä–µ–±–Ω–æ –∑–∞ —Å—Ç—É–¥–µ–Ω—Ç—Å–∫–∞—Ç–∞ —Å–ª—É–∂–±–∞ –¥–∞ –≥–æ
//–æ–ø—Å–ª—É–∂–∏, –¥–∞ —Å–µ –æ–¥—Ä–µ–¥–∏ –∫–æ—ò —Å—Ç—É–¥–µ–Ω—Ç —ú–µ –±–∏–¥–µ –ø—Ä–≤–∏–æ—Ç —Å—Ç—É–¥–µ–Ω—Ç
//–∫–æ—ò –Ω–µ–º–∞ –¥–∞ –±–∏–¥–µ –æ–ø—Å–ª—É–∂–µ–Ω –∏ –∫–æ–ª–∫—É —Å—Ç—É–¥–µ–Ω—Ç–∏ —à—Ç–æ —á–µ–∫–∞–ª–µ –≤–æ
//—Ä–µ–¥–∏—Ü–∞—Ç–∞ –∑–∞ —Ç–æ—ò –¥–µ–Ω –Ω–µ —Å–µ –æ–ø—Å–ª—É–∂–µ–Ω–∏.

class Student{
    String index;
    int minutes;

    Student(String index, int minutes){
        this.index = index;
        this.minutes = minutes;
    }
}

public class Main {

    static Student firstUnservedStuden(Queue<Student> q) {
        int availableTime=180;
        while(!q.isEmpty()){
            Student s = q.peek();
            if(s.minutes > availableTime){
                return s;
            }
            availableTime-=s.minutes;
        q.poll();
        }
        return null;
    };

    public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int n=sc.nextInt();
            sc.nextLine();
            Queue<Student>queue=new LinkedList<>();
            for(int i=0;i<n;i++){
                String index=sc.nextLine();

                int minutes=sc.nextInt();
                sc.nextLine();
                queue.add(new Student(index,minutes));
            }

            Student unserved=firstUnservedStuden(queue);

            if(unserved==null){
                System.out.println("all students served lil bro");
            }
            else{
                System.out.println(unserved.index);
                System.out.println(queue.size());
            }
    }
}



 Infix to Postfix
–ö–æ—Ä–∏—Å—Ç–µj¬¥–∫–∏ j–∞ –ø–æ–¥–∞—Ç–æ—á–Ω–∞—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–∞–≥–∞—Ü–∏–Ω (—Å—Ç–µ–∫), –ø—Ä–æ–º–µ–Ω–µ—Ç–µ –≥–æ –∏–∑—Ä–∞–∑–æ—Ç –æ–¥
infix –≤–æ postfix –Ω–æ—Ç–∞—Ü–∏j–∞.
Infix –Ω–æ—Ç–∞—Ü–∏j–∞: –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ—Ç —Å–µ –Ω–∞–æ¬¥–≥–∞ –ø–æ–º–µ¬¥–≥—É –æ–ø–µ—Ä–∞–Ω–¥–∏—Ç–µ ( 5 + 9 ) * 2 + 6 * 5 .
Postfix –Ω–æ—Ç–∞—Ü–∏j–∞: –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ —Å–µ –∑–∞–ø–∏—à—É–≤–∞–∞—Ç –ø–æ—Å–ª–µ –æ–ø–µ—Ä–∞–Ω–¥–∏—Ç–µ 5 9 + 2 * 6 5 *
+.
–í–ª–µ–∑: –í–æ –≤–ª–µ–∑–æ—Ç –µ –¥–∞–¥–µ–Ω –∏–∑—Ä–∞–∑–æ—Ç –≤–æ infix –Ω–æ—Ç–∞—Ü–∏j–∞.
–ò–∑–ª–µ–∑: –ù–∞ –∏–∑–ª–µ–∑ —Ç—Ä–µ–±–∞ –¥–∞ —Å–µ –∏—Å–ø–µ—á–∞—Ç–∏ –∏–∑—Ä–∞–∑–æ—Ç –≤–æ postfix –Ω–æ—Ç–∞—Ü–∏j–∞.
–ó–∞–±–µ–ª–µ—à–∫–∞: –ü—Ä–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏j–∞ –Ω–∞ –∑–∞–¥–∞—á–∞—Ç–∞ –¥–æ–∑–≤–æ–ª–µ–Ω–æ e –¥–∞ —Å–µ –∫–æ—Ä–∏—Å—Ç–∏ —Å–∞–º–æ
–µ–¥–µ–Ω —Å—Ç–µ–∫. –ù–µ –µ –¥–æ–∑–≤–æ–ª–µ–Ω–æ –¥–∞ —Å–µ –∫–æ—Ä–∏—Å—Ç–∞—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –∫–∞–∫–æ –Ω–∏–∑–∏ –∏
–ª–∏—Å—Ç–∏.
–ü—Ä–∏–º–µ—Ä:
–í–ª–µ–∑: ùëé + ùëè * (ùëê
‚àßùëë ‚àí ùëí)
‚àß
(ùëì + ùëî * ‚Ñé) ‚àí ùëñ
–ò–∑–ª–µ–∑: ùëéùëèùëêùëë‚àß
ùëí ‚àí ùëìùëî‚Ñé * +‚àß * +ùëñ‚àí
–†–µ—à–µ–Ω–∏–µ
–í–æ –¥–∞–¥–µ–Ω–∞—Ç–∞ –∑–∞–¥–∞—á–∞ —Ç—Ä–µ–±–∞ –¥–∞ —Å–µ –ø—Ä–æ–º–µ–Ω–∏ –¥–∞–¥–µ–Ω –∏–∑—Ä–∞–∑ –æ–¥ infix –≤–æ postfix –Ω–æ—Ç–∞—Ü–∏j–∞.
–í–æ –ø–æ—Å—Ç—Ñ–∏–∫—Å –Ω–æ—Ç–∞—Ü–∏j–∞—Ç–∞, –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ —Å–ª–µ–¥–∞—Ç –ø–æ –æ–ø–µ—Ä–∞–Ω–¥–∏—Ç–µ. –ú–æ—Ä–∞ –¥–∞ —Å–µ –∫–æ—Ä–∏—Å—Ç–∏
—Å—Ç–µ–∫ –∑–∞ –¥–∞ —Å–µ –æ—Ä–≥–∞–Ω–∏–∑–∏—Ä–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞—Ç–∞ –Ω–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ –∏ –¥–∞ —Å–µ –∏–∑–≥—Ä–∞–¥–∏ –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∏–æ—Ç –∏–∑—Ä–∞–∑. –°–æ –∫–æ—Ä–∏—Å—Ç–µ—ö–µ –Ω–∞ —Å—Ç–µ–∫, –º–æ–∂–µ–º–µ –¥–∞ –Ω–∞–ø–∏—à–µ–º–µ –µ—Ñ–∏–∫–∞—Å–µ–Ω –∞–ª–≥–æ—Ä–∏—Ç–∞–º
–∑–∞ –ø—Ä–µ–≤–µ–¥—É–≤–∞—ö–µ –Ω–∞ –∏–Ω—Ñ–∏–∫—Å–Ω–∏–æ—Ç –∏–∑—Ä–∞–∑ –≤–æ –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∞ –Ω–æ—Ç–∞—Ü–∏j–∞, —à—Ç–æ –æ–≤–æ–∑–º–æ–∂—É–≤–∞
–ø–æ–¥–æ—Ü–Ω–∞ –ª–µ—Å–Ω–æ –∏–∑–≤—Ä—à—É–≤–∞—ö–µ –Ω–∞ –∏–∑—Ä–∞–∑–æ—Ç –±–µ–∑ –ø–æ—Ç—Ä–µ–±–∞ –æ–¥ –∞–Ω–∞–ª–∏–∑–∞ –Ω–∞ –∏–Ω—Ñ–∏–∫—Å–Ω–∞—Ç–∞
—Å—Ç—Ä—É–∫—Ç—É—Ä–∞.
99
–ü–æ–¥–∞—Ç–æ—á–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏
–ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏j–∞—Ç–∞ –Ω–∞ —Ä–µ—à–µ–Ω–∏–µ—Ç–æ –µ –¥–∞–¥–µ–Ω–∞ –ø–æ–¥–æ–ª—É. –í–æ –æ–≤–∞–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏j–∞
–º–µ—Ç–æ–¥–æ—Ç infixToPostfix –≤—Ä–∞¬¥–∫–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç –≤–æ –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∞ –Ω–æ—Ç–∞—Ü–∏j–∞. –û–ø–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ –≤–æ
–∏–Ω—Ñ–∏–∫—Å–Ω–∞—Ç–∞ –Ω–æ—Ç–∞—Ü–∏j–∞ –∏–º–∞–∞—Ç —Ä–∞–∑–ª–∏—á–Ω–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∏ (–Ω–∞ –ø—Ä–∏–º–µ—Ä, * –∏ / –∏–º–∞–∞—Ç –ø–æ–≥–æ–ª–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ–¥ + –∏ -). –°—Ç–µ–∫–æ—Ç –æ–≤–æ–∑–º–æ–∂—É–≤–∞ –µ—Ñ–∏–∫–∞—Å–Ω–æ —Å–ª–µ–¥–µ—ö–µ –Ω–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∏—Ç–µ
–Ω–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ –∏ –ø—Ä–∞–≤–∏–ª–Ω–æ—Ç–æ —Ä–µ–¥–æ—Å–ª–µ–¥—É–≤–∞—ö–µ –Ω–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ –≤–æ –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∞—Ç–∞
–Ω–æ—Ç–∞—Ü–∏j–∞. –ö–æ–≥–∞ —Å–µ —Å—Ä–µ—Ç–Ω–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä –≤–æ –∏–Ω—Ñ–∏–∫—Å–Ω–∏–æ—Ç –∏–∑—Ä–∞–∑, –∞–∫–æ –∏–º–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏ –Ω–∞
–≤—Ä–≤–æ—Ç –Ω–∞ —Å—Ç–µ–∫–æ—Ç —Å–æ –ø–æ–≥–æ–ª–µ–º –∏–ª–∏ –∏—Å—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç, —Ç–∏–µ —Å–µ –ø—Ä–µ–º–µ—Å—Ç—É–≤–∞–∞—Ç –Ω–∞ –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∏–æ—Ç –∏–∑—Ä–∞–∑ –ø—Ä–µ–¥ —Ç–∞–∞ –Ω–æ–≤–∞ –æ–ø–µ—Ä–∞—Ü–∏j–∞. –ò—Å—Ç–æ —Ç–∞–∫–∞, —Å—Ç–µ–∫–æ—Ç —Å–µ –∫–æ—Ä–∏—Å—Ç–∏ –∑–∞ –¥–∞ —Å–µ —Å–ª–µ–¥–∞—Ç
–∑–∞–≥—Ä–∞–¥–∏—Ç–µ ( –∏ ) –≤–æ –∏–∑—Ä–∞–∑–æ—Ç –∏ –¥–∞ —Å–µ –æ—Å–∏–≥—É—Ä–∞ –¥–µ–∫–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ –º–µ¬¥–≥—É –∑–∞–≥—Ä–∞–¥–∏—Ç–µ —Å–µ
–æ–±—Ä–∞–±–æ—Ç—É–≤–∞–∞—Ç —Å–æ–æ–¥–≤–µ—Ç–Ω–æ. –†–µ–∑—É–ª—Ç–∞—Ç–æ—Ç –æ–¥ –ø—Ä–∏–º–µ—Ä–µ–Ω –∏–∑—Ä–∞–∑ –≤–æ –ø–æ—Å—Ç—Ñ–∏–∫—Å –Ω–æ—Ç–∞—Ü–∏j–∞ —Å–æ
–ø–æ–≤–∏–∫—É–≤–∞—ö–µ –Ω–∞ infixToPostfix –º–µ—Ç–æ–¥–æ—Ç —Å–µ –ø–µ—á–∞—Ç–∏ –Ω–∞ –∏–∑–ª–µ–∑ –≤–æ –≥–ª–∞–≤–Ω–∏–æ—Ç main –º–µ—Ç–æ–¥



public class Main {
    // Check if a character is an operator
    private static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
    }

    // Get precedence of an operator
    private static int getPrecedence(char op) {
        switch (op) {
            case '^': return 3;
            case '*':
            case '/': return 2;
            case '+':
            case '-': return 1;
            default: return 0;
        }
    }

    // Convert infix to postfix
    public static String infixToPostfix(String infix) {
        ArrayStack<Character> stack = new ArrayStack<>(100);
        StringBuilder postfix = new StringBuilder();

        for (int i = 0; i < infix.length(); i++) {
            char c = infix.charAt(i);

            // Skip whitespace
            if (c == ' ') continue;

            // Operand: add to postfix
            if (Character.isLetterOrDigit(c)) {
                postfix.append(c);
            }
            // Left parenthesis: push to stack
            else if (c == '(') {
                stack.push(c);
            }
            // Right parenthesis: pop until '('
            else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                stack.pop(); // Remove '(' from stack
            }
            // Operator: handle precedence
            else if (isOperator(c)) {
                while (!stack.isEmpty() && getPrecedence(stack.peek()) >= getPrecedence(c)) {
                    postfix.append(stack.pop());
                }
                stack.push(c);
            }
        }

        // Pop remaining operators
        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }

        return postfix.toString();
    }

    public static void main(String[] args) {
        String infix = "a + b * (c ^ d - e) ^ (f + g * h) - i";
        String postfix = infixToPostfix(infix);
        System.out.println("Postfix: " + postfix); // Output: abcd^e-fgh*+^*+i-
    }
}
