Задача 1. Избриши последно поjавување на броj
Дадена е еднострано поврзана листа чии што jазли содржат цели броеви. За
даден броj од тастатура, потребно е да се отстрани неговото последно поjавување
(да се избрише jазолот што го содржи броjот).
Влез: Во првата линиjа е даден броjот на елементи n. Во следните n линии
се дадени елементите на листата. Во последната линиjа е даден броjот коj треба
да се отстрани (неговото последно поjавување).
Излез: На излез треба да се испечатат jазлите на резултантната листа.
Пример.
Влез:
5
4
6
4
9
3
4
Излез:
4->6->9->3
Решение
Решението е дадено во main методата во IzbrishiPosleden класата.



public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n=sc.nextInt();

        SLL<Integer> list = new SLL<>();

        for (int i = 0; i < n; i++) {
            list.insertLast(sc.nextInt());
        }

        int m=sc.nextInt();

        System.out.println(list);

        SLLNode<Integer> current = list.getFirst();
        SLLNode<Integer> deleter = null;

        while (current != null) {

            if (current.element.equals(m)) {
                deleter = current;
            }
            current=current.succ;
        }
        if(deleter!=null){
            list.delete(deleter);
            System.out.println(list);
        }
    }
}



Задача 2. Замени соседи
Дадена е еднострано поврзана листа чии што jазли содржат по еден природен
броj. Да се трансформира листата така што секоj соседен пар jазли ´ке си ги
заменат местата (првиот со вториот, па третиот со четвртиот итн...).
Влез: Во првата линиjа е даден броjот на елементи n. Во следните n линии
се дадени елементите на листата.
Излез: На излез треба да се испечатат jазлите на резултантната листа.
Пример.
Влез:
4
1
2
3
4
Излез:
2->1->4->3



public class Main {
    public static void main(String[] args) {
     Scanner sc = new Scanner(System.in);

     int n=sc.nextInt();

     SLL<Integer> list=new SLL<>();

     for(int i=0;i<n;i++){
         list.insertLast(sc.nextInt());
     }

     SLLNode<Integer> current=list.getFirst();
     SLLNode<Integer> prev=null;

     System.out.println(list);

    while(current!=null && current.succ!=null){
        int temp= current.element;
        current.element=current.succ.element;
        current.succ.element=temp;
        current=current.succ.succ;
    }
    System.out.println(list);

    }
}



Задача 3. Раздели листа
Дадена е еднострано поврзана листа со природни броеви. Да се креираат две
резултантни еднострано поврзани листи т.ш. во првата листа ´ке се земаат само
jазлите што содржат парни броj, при што доколку во првичната листа има пове´ке
соседни jазли со парни броеви се зема само последниот jазел. Слична процедура
се применува и за втората резултантна листа, при што овде се земаат само jазлите
што содржат непарни броеви, при што ако има пове´ке соседни jазли со непарни
броеви се зема само последниот jазел.
Влез: Во првата линиjа е даден броjот на елементи n. Во втората линиjа се
даваат броевите во листата одделени со празно место.
Излез: Прво се печати резултантната листа со прости броеви, а потоа во нов
ред таа со непрости. Доколку некоjа од листите е празна се печати: Prazna lista.
Пример.
Влез:
8
1 3 2 4 5 7 6 8
Излез:
4->8
3->7

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();

        SLL<Integer> list = new SLL<>();
        SLL<Integer> evenList = new SLL<>();
        SLL<Integer> oddList = new SLL<>();

        for (int i = 0; i < n; i++) {
            list.insertLast(sc.nextInt());
        }

        SLLNode<Integer> current = list.getFirst();
        Integer lastEven = null, lastOdd = null;

        while (current != null) {
            // Keep track of the last even or odd number in a sequence
            if (current.element % 2 == 0) {
                lastEven = current.element;
            } else {
                lastOdd = current.element;
            }

            // If the next node is null or a different parity, store the last one
            if (current.succ == null || (current.succ.element % 2 != current.element % 2)) {
                if (lastEven != null && current.element % 2 == 0) {
                    evenList.insertLast(lastEven);
                    lastEven = null;
                }
                if (lastOdd != null && current.element % 2 != 0) {
                    oddList.insertLast(lastOdd);
                    lastOdd = null;
                }
            }

            current = current.succ;  // Move to the next node
        }

        // Print results
        if (evenList.size() == 0) {
            System.out.println("Prazna lista");
        } else {
            System.out.println(evenList);
        }

        if (oddList.size() == 0) {
            System.out.println("Prazna lista");
        } else {
            System.out.println(oddList);
        }


    }
}

-------------------------------------------------------------------


import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;

         public class RazdeliLista {
 public static void main(String[] args) throws IOException {

        SLL<Integer> lista = new SLL<Integer>();
        SLL<Integer> parni = new SLL<Integer>();
         SLL<Integer> neparni = new SLL<Integer>();
       BufferedReader stdin = new BufferedReader(new
                InputStreamReader(System.in));
         String s = stdin.readLine();
         int N = Integer.parseInt(s);
         s = stdin.readLine();
        String[] pomniza = s.split(" ");
        for (int i = 0; i < N; i++) {
             lista.insertLast(Integer.parseInt(pomniza[i]));
            }

         SLLNode<Integer> pom = lista.getFirst();

         while(pom!=null){
             while(pom.succ!=null && pom.element%2==0 && pom.succ.element%2==0){
                 pom=pom.succ;
                 }
             while(pom.succ!=null && !(pom.element%2==0) &&
                    !(pom.succ.element%2==0)){
                 pom=pom.succ;
                }
             if(pom.element%2==0)
                parni.insertLast(pom.element);
             else
             neparni.insertLast(pom.element);
             pom = pom.succ;
             }

         if(parni.size()==0) System.out.println("Prazna lista");
         else System.out.println(parni);



         if(neparni.size()==0) System.out.println("Prazna lista");
         else System.out.println(neparni);
         }
 }





